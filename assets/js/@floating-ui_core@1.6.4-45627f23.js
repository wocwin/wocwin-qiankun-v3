import{e,g as t,r as n,a,c as i,b as l,d as o,f as s,h as r,i as c,j as f,k as m,l as g,m as u,n as y}from"./@floating-ui_utils@0.2.4-2382c5cb.js";function d(e,t,n){let{reference:i,floating:r}=e;const c=s(t),f=a(t),m=g(f),u=o(t),y="y"===c,d=i.x+i.width/2-r.width/2,p=i.y+i.height/2-r.height/2,x=i[m]/2-r[m]/2;let w;switch(u){case"top":w={x:d,y:i.y-r.height};break;case"bottom":w={x:d,y:i.y+i.height};break;case"right":w={x:i.x+i.width,y:p};break;case"left":w={x:i.x-r.width,y:p};break;default:w={x:i.x,y:i.y}}switch(l(t)){case"start":w[f]-=x*(n&&y?-1:1);break;case"end":w[f]+=x*(n&&y?-1:1)}return w}const p=async(e,t,n)=>{const{placement:a="bottom",strategy:i="absolute",middleware:l=[],platform:o}=n,s=l.filter(Boolean),r=await(null==o.isRTL?void 0:o.isRTL(t));let c=await o.getElementRects({reference:e,floating:t,strategy:i}),{x:f,y:m}=d(c,a,r),g=a,u={},y=0;for(let p=0;p<s.length;p++){const{name:n,fn:l}=s[p],{x:x,y:w,data:v,reset:h}=await l({x:f,y:m,initialPlacement:a,placement:g,strategy:i,middlewareData:u,rects:c,platform:o,elements:{reference:e,floating:t}});f=null!=x?x:f,m=null!=w?w:m,u={...u,[n]:{...u[n],...v}},h&&y<=50&&(y++,"object"==typeof h&&(h.placement&&(g=h.placement),h.rects&&(c=!0===h.rects?await o.getElementRects({reference:e,floating:t,strategy:i}):h.rects),({x:f,y:m}=d(c,g,r))),p=-1)}return{x:f,y:m,placement:g,strategy:i,middlewareData:u}};async function x(a,i){var l;void 0===i&&(i={});const{x:o,y:s,platform:r,rects:c,elements:f,strategy:m}=a,{boundary:g="clippingAncestors",rootBoundary:u="viewport",elementContext:y="floating",altBoundary:d=!1,padding:p=0}=e(i,a),x=t(p),w=f[d?"floating"===y?"reference":"floating":y],v=n(await r.getClippingRect({element:null==(l=await(null==r.isElement?void 0:r.isElement(w)))||l?w:w.contextElement||await(null==r.getDocumentElement?void 0:r.getDocumentElement(f.floating)),boundary:g,rootBoundary:u,strategy:m})),h="floating"===y?{x:o,y:s,width:c.floating.width,height:c.floating.height}:c.reference,b=await(null==r.getOffsetParent?void 0:r.getOffsetParent(f.floating)),R=await(null==r.isElement?void 0:r.isElement(b))&&await(null==r.getScale?void 0:r.getScale(b))||{x:1,y:1},A=n(r.convertOffsetParentRelativeRectToViewportRelativeRect?await r.convertOffsetParentRelativeRectToViewportRelativeRect({elements:f,rect:h,offsetParent:b,strategy:m}):h);return{top:(v.top-A.top+x.top)/R.y,bottom:(A.bottom-v.bottom+x.bottom)/R.y,left:(v.left-A.left+x.left)/R.x,right:(A.right-v.right+x.right)/R.x}}const w=n=>({name:"arrow",options:n,async fn(o){const{x:s,y:r,placement:c,rects:f,platform:m,elements:y,middlewareData:d}=o,{element:p,padding:x=0}=e(n,o)||{};if(null==p)return{};const w=t(x),v={x:s,y:r},h=a(c),b=g(h),R=await m.getDimensions(p),A="y"===h,E=A?"top":"left",P=A?"bottom":"right",k=A?"clientHeight":"clientWidth",O=f.reference[b]+f.reference[h]-v[h]-f.floating[b],D=v[h]-f.reference[h],T=await(null==m.getOffsetParent?void 0:m.getOffsetParent(p));let L=T?T[k]:0;L&&await(null==m.isElement?void 0:m.isElement(T))||(L=y.floating[k]||f.floating[b]);const B=O/2-D/2,S=L/2-R[b]/2-1,j=u(w[E],S),C=u(w[P],S),F=j,V=L-R[b]-C,H=L/2-R[b]/2+B,W=i(F,H,V),_=!d.arrow&&null!=l(c)&&H!==W&&f.reference[b]/2-(H<F?j:C)-R[b]/2<0,q=_?H<F?H-F:H-V:0;return{[h]:v[h]+q,data:{[h]:W,centerOffset:H-W-q,..._&&{alignmentOffset:q}},reset:_}}}),v=function(t){return void 0===t&&(t={}),{name:"flip",options:t,async fn(n){var a,i;const{placement:l,middlewareData:g,rects:u,initialPlacement:y,platform:d,elements:p}=n,{mainAxis:w=!0,crossAxis:v=!0,fallbackPlacements:h,fallbackStrategy:b="bestFit",fallbackAxisSideDirection:R="none",flipAlignment:A=!0,...E}=e(t,n);if(null!=(a=g.arrow)&&a.alignmentOffset)return{};const P=o(l),k=s(y),O=o(y)===y,D=await(null==d.isRTL?void 0:d.isRTL(p.floating)),T=h||(O||!A?[r(y)]:c(y)),L="none"!==R;!h&&L&&T.push(...f(y,A,R,D));const B=[y,...T],S=await x(n,E),j=[];let C=(null==(i=g.flip)?void 0:i.overflows)||[];if(w&&j.push(S[P]),v){const e=m(l,u,D);j.push(S[e[0]],S[e[1]])}if(C=[...C,{placement:l,overflows:j}],!j.every((e=>e<=0))){var F,V;const e=((null==(F=g.flip)?void 0:F.index)||0)+1,t=B[e];if(t)return{data:{index:e,overflows:C},reset:{placement:t}};let n=null==(V=C.filter((e=>e.overflows[0]<=0)).sort(((e,t)=>e.overflows[1]-t.overflows[1]))[0])?void 0:V.placement;if(!n)switch(b){case"bestFit":{var H;const e=null==(H=C.filter((e=>{if(L){const t=s(e.placement);return t===k||// Create a bias to the `y` side axis due to horizontal
// reading directions favoring greater width.
"y"===t}return!0})).map((e=>[e.placement,e.overflows.filter((e=>e>0)).reduce(((e,t)=>e+t),0)])).sort(((e,t)=>e[1]-t[1]))[0])?void 0:H[0];e&&(n=e);break}case"initialPlacement":n=y}if(l!==n)return{reset:{placement:n}}}return{}}}};const h=function(t){return void 0===t&&(t=0),{name:"offset",options:t,async fn(n){var a,i;const{x:r,y:c,placement:f,middlewareData:m}=n,g=await async function(t,n){const{placement:a,platform:i,elements:r}=t,c=await(null==i.isRTL?void 0:i.isRTL(r.floating)),f=o(a),m=l(a),g="y"===s(a),u=["left","top"].includes(f)?-1:1,y=c&&g?-1:1,d=e(n,t);let{mainAxis:p,crossAxis:x,alignmentAxis:w}="number"==typeof d?{mainAxis:d,crossAxis:0,alignmentAxis:null}:{mainAxis:0,crossAxis:0,alignmentAxis:null,...d};return m&&"number"==typeof w&&(x="end"===m?-1*w:w),g?{x:x*y,y:p*u}:{x:p*u,y:x*y}}(n,t);return f===(null==(a=m.offset)?void 0:a.placement)&&null!=(i=m.arrow)&&i.alignmentOffset?{}:{x:r+g.x,y:c+g.y,data:{...g,placement:f}}}}},b=function(t){return void 0===t&&(t={}),{name:"shift",options:t,async fn(n){const{x:a,y:l,placement:r}=n,{mainAxis:c=!0,crossAxis:f=!1,limiter:m={fn:e=>{let{x:t,y:n}=e;return{x:t,y:n}}},...g}=e(t,n),u={x:a,y:l},d=await x(n,g),p=s(o(r)),w=y(p);let v=u[w],h=u[p];if(c){const e="y"===w?"bottom":"right",t=v+d["y"===w?"top":"left"],n=v-d[e];v=i(t,v,n)}if(f){const e="y"===p?"bottom":"right",t=h+d["y"===p?"top":"left"],n=h-d[e];h=i(t,h,n)}const b=m.fn({...n,[w]:v,[p]:h});return{...b,data:{x:b.x-a,y:b.y-l}}}}};export{w as a,p as c,x as d,v as f,h as o,b as s};
